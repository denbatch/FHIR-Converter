targetScope = 'subscription'

@minLength(3)
@maxLength(9)
@description('Used as the prefix to name provisioned resources where a custom name is not provided. Should be alphanumeric, at least 3 characters and no more than 9 characters.')
param serviceName string

@description('Location where the resources are deployed.')
@allowed([
  'australiaeast'
  'brazilsouth'
  'canadacentral'
  'canadaeast'
  'centralindia'
  'centralus'
  'chinanorth3'
  'eastasia'
  'eastus'
  'eastus2'
  'francecentral'
  'germanywestcentral'
  'japaneast'
  'koreacentral'
  'northcentralus'
  'northeurope'
  'norwayeast'
  'southafricanorth'
  'southcentralus'
  'southeastasia'
  'swedencentral'
  'switzerlandnorth'
  'uaenorth'
  'uksouth'
  'westeurope'
  'westus'
  'westus2'
  'westus3'
])
param location string

@description('Name of the resource group to deploy the resources to. If the resource group does not already exist, a new resource group will be provisioned with the given name or with an autogenerated name based on serviceName if one is not provided.')
param resourceGroupName string = '${serviceName}-rg'

@description('Set to true to deploy a storage account for storing custom templates.')
param deployTemplateStore bool

@description('Name of storage account containing custom templates. If a name is not provided and deployTemplateStore is true, an autogenerated name based on serviceName will be used.')
param templateStorageAccountName string = deployTemplateStore ? '${serviceName}templatestorage' : '' 

@description('Name of storage account container containing custom templates. If a name is not provided and deployTemplateStore is true, an autogenerated name based on serviceName will be used.')
param templateStorageAccountContainerName string = deployTemplateStore ? '${serviceName}templatecontainer' : ''

@description('Name of the container app environment. If a name is not provided, an autogenerated name based on serviceName will be used.')
param containerAppEnvName string = '${serviceName}-app-env'

@description('Name of the container app to run the fhirconverter service. If a name is not provided, an autogenerated name based on serviceName will be used.')
param containerAppName string = '${serviceName}-app'

@description('Minimum number of replicas for the container app.')
param minReplicas int = 0

@description('Maximum number of replicas for the container app.')
param maxReplicas int = 30

@description('CPU limit for the container app.')
param cpuLimit string = '1.0'

@description('Memory limit for the container app.')
param memoryLimit string = '2Gi'

@description('If set to true, authentication will be enabled on the API endpoint.')
param authenticationEnabled bool = false

@description('Audiences for the api authentication.')
param authenticationAudiences array = []

@description('Authority for the api authentication.')
param authenticationAuthority string = ''

@description('If set to true, Application Insights logs and metrics collection will be enabled for the container app.')
param enableApplicationInsights bool = true

@description('The tag of the image to pull from MCR. To see available image versions, visit the [FHIR Converter MCR page](https://mcr.microsoft.com/en-us/product/healthcareapis/fhir-converter/tags)')
param containerAppImageTag string

var deploymentTemplateVersion = '1'

var containerAppImageName = 'healthcareapis/fhir-converter'

resource resourceGroup 'Microsoft.Resources/resourceGroups@2020-06-01' = {
  name: resourceGroupName
  location: location
  tags: {
    fhirConverterDeploymentTemplateVersion: deploymentTemplateVersion
  }
}

module templateStoreDeploy 'Deploy-TemplateStore.bicep' = if (deployTemplateStore) {
  name: 'templateStoreDeploy'
  scope: resourceGroup
  params: {
    location: location
    templateStorageAccountName: templateStorageAccountName
    templateStorageAccountContainerName: templateStorageAccountContainerName
  }
}

module convertInfrastructureDeploy 'Infrastructure-Setup.bicep' = {
  name: 'convertInfrastructureDeploy'
  scope: resourceGroup
  params: {
    location: location
    envName: containerAppEnvName
    enableApplicationInsights: enableApplicationInsights
  }
}

module fhirConverterDeploy 'Deploy-FhirConverterService.bicep' = {
  name: 'fhirConverterDeploy'
  scope: resourceGroup
  params: {
    location: location
    appName: containerAppName
    envName: convertInfrastructureDeploy.outputs.containerAppEnvironmentName
    minReplicas: minReplicas
    maxReplicas: maxReplicas
    cpuLimit: cpuLimit
    memoryLimit: memoryLimit
    authenticationEnabled: authenticationEnabled
    authenticationAudiences: authenticationAudiences
    authenticationAuthority: authenticationAuthority
    templateStorageAccountName: deployTemplateStore ? templateStoreDeploy.outputs.templateStorageAccountName : templateStorageAccountName
    templateStorageAccountContainerName: deployTemplateStore ? templateStoreDeploy.outputs.templateStorageAccountContainerName : templateStorageAccountContainerName
    imageTag: containerAppImageTag
    applicationInsightsConnectionString: enableApplicationInsights ? convertInfrastructureDeploy.outputs.applicationInsightsConnectionString : ''
    applicationInsightsUAMIClientId: enableApplicationInsights ? convertInfrastructureDeploy.outputs.applicationInsightsUAMIClientId : ''
    applicationInsightsUAMIResourceId: enableApplicationInsights ? convertInfrastructureDeploy.outputs.applicationInsightsUAMIResourceId : ''
    containerAppEnvironmentId: convertInfrastructureDeploy.outputs.containerAppEnvironmentId
  }
  dependsOn: [
    templateStoreDeploy
    convertInfrastructureDeploy
  ]
}

output fhirConverterApiEndpoint string = fhirConverterDeploy.outputs.containerAppFQDN
output resourceGroupName string = resourceGroup.name